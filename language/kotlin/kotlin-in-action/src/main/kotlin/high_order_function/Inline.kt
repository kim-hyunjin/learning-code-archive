package high_order_function

import java.util.concurrent.locks.Lock


/**
 * 인라인 함수: 람다의 부가 비용 없애기
 * 코틀린에서 람다를 함수 인자로 넘기는 구문은 if나 for와 같은 일반 문장과 비슷하다.
 *
 * 코틀린이 보통 람다를 무명 클래스로 컴파일하지만 그렇다고 람다 식을 사용할 때마다 새로운 클래스가 만들어지지는 않는다
 * 람다가 변수를 포획하면 람다가 생성되는 시점마다 새로운 무명 클래스 객체가 생긴다
 * 이런 경우 실행 시점에 무명 클래스 생성에 따른 부가 비용이 든다.
 * 따라서 람다를 사용하는 구현은 똑같은 작업을 수행하는 일반 함수를 사용한 구현보다 덜 효율적이다.
 *
 * 반복되는 코드를 별도의 라이브러리 함수로 빼내되 컴파일러가 자바의 일반 명령문만큼 효율적인 코드를 생성하게 만들 수는 없을까?
 * inline 변경자를 어떤 함수에 붙이면 컴파일러는 그 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해준다.
 */

/**
 * 인라이닝이 작동하는 방식
 *
 */

inline fun <T> synchronized(lock: Lock, action: () -> T): T {
    lock.lock()
    try {
        return action()
    }
    finally {
        lock.unlock()
    }
}

fun foo(l: Lock) {
    println("Before sync")
    synchronized(l) {
        println("Action")
    }
    println("After sync")
}
/*
    위 foo 함수를 컴파일한 버전
    fun __foo__(l: Lock) {
        println("Before sync")
        lock.lock()
        try {
            println("Action") // synchronized 에 전달된 람다의 본문도 인라이닝 된다.
        }
        finally {
            lock.unlock()
        }
        println("After sync")
    }

    람다의 본문에 의해 만들어지는 바이트코드는 그 람다를 호출하는 코드 정의의 일부분으로 간주되기 때문에
    코틀린 컴파일러는 그 람다를 함수 인터페이스를 구현하는 무명 클래스로 감싸지 않는다.

    람다를 넘기는 대신 함수 타입의 변수를 넘기는 경우에는 인라이닝 되지 않는다.
*/

/**
 * 인라인 함수의 한계
 * 인라이닝 하는 방식으로 인해 람다를 사용하는 모든 함수를 인라이닝할 수는 없다.
 * 함수가 인라이닝될 때 그 함수에 인자로 전달된 람다 식의 본문은 결과 코드에 직접 들어갈 수 있다.
 * 하지만 이렇게 람다가 본문에 직접 펼쳐지기 때문에 함수가 파라미터로 전달받은 람다를 본문에 사용하는 방식이 한정될 수 밖에 없다.
 * 함수 본문에서 파라미터로 받은 람다를 호출한다면 그 호출을 쉽게 람다 본문으로 바꿀 수 있다.
 * 하지만 파라미터로 받은 람다를 다른 변수에 저장하고 나중에 그 변수를 사용한다면 람다를 표현하는 객체가
 * 어딘가는 존재해야 하기 때문에 인라이닝 할 수 없다.
 *
 * 일반적으로 인라인 함수의 본문에서 람다 식을 바로 호출하거나 람다 식을 인자로 전달받아 바로 호출하는 경우에는 그 람다를 인라닝할 수 있다.
 *
 * 그런 경우가 아니라면 컴파일러는 Illegal usage of inline-parameter 라는 메시지와 함께 인라이닝을 금지시킨다.
 *
 * 인자로 받는 함수에서 인라이닝하면 안 되는 람다를 파라미터로 받는다면 noinline 변경자를 붙여서 인라이닝을 금지할 수 있다.
 */

/**
 * 컬렉션 연산 인라이닝
 *
 * filter, map은 인라인 함수다. 두 함수의 본문은 인라이닝되며, 추가 객체나 클래스 생성은 없다.
 *
 */
data class Person2(val name: String, val age: Int)

/**
 * 함수를 인라인으로 선언해야 하는 case
 * 일반 함수 호출의 경우 JVM은 이미 강력하게 인라이닝을 지원한다.
 * JVM은 코드 실행을 분석해서 가장 이익이 되는 방향으로 호출을 인라이닝한다.
 * 이런 과정은 바이트코드를 실제 기계어 코드로 번역하는 과정(JIT)에서 일어난다.
 * 이런 JVM의 최적화를 활용한다면 바이트코드에서는 각 함수 구현이 정확히 한 번만 있으면 되고,
 * 그 함수를 호출하는 부분에서 따로 함수 코드를 중복할 필요가 없다.
 *
 * 반면 코틀린 인라인 함수는 바이트코드에서 각 함수 호출 지점을 함수 본문으로 대치하기 때문에 코드 중복이 생긴다.
 * 게다가 함수를 직접 호출하면 스택 트레이스가 더 깔끔해진다.
 *
 * 반면 람다를 인자로 받는 함수를 인라이닝하면 이익이 더 많다.
 *
 * 첫째로 인라이닝을 통해 없앨 수 있는 부가 비용이 상당하다.
 * 함수 호출 비용을 줄일 수 있을 뿐 아니라 람다를 표현하는 클래스와 람다 인스턴스에 해당하는 객체를 만들 필요도 없어진다.
 *
 * 둘째로 현재의 JVM은 함수 호출과 람다를 인라이닝해 줄 정도로 똑똑하지는 못하다.
 *
 * 마지막으로 인라이닝을 사용하면 일반 람다에서는 사용할 수 없는 몇가지 기능을 사용할 수 있다.
 * 그런 기능 중에는 non-local 변환이 있다.
 *
 * 하지만 inline 변경자를 함수에 붙일때는 코드 크기에 주의를 기울여야 한다.
 * 바이트코드가 전체적으로 아주 커질 수 있다. 그런 경우 람다 인자와 무관한 코드를 별도의 비인라인 함수로 빼낼 수도 있다.
 */
fun main() {
    val people = listOf(Person2("Alice", 29), Person2("Bob", 31))
    println(people.filter { it.age < 30 })

    val result = mutableListOf<Person2>()
    for (person in people) {
        if (person.age < 30) result.add(person)
    }
    println(result)
    // 위의 인라인 함수와 아래의 일반 함수는 성능이 거의 같다.

    println(people.filter { it.age > 30 }.map(Person2::name))
    // filter와 map을 연속해서 사용한 예.
    // 이 코드는 중간 리스트를 만든다. 처리할 원소가 많아지면 중간 리스트를 사용하는 부가 비용도 걱정할 만큼 커진다.
    // asSequence를 통해 리스트 대신 시퀀스를 사용하면 중간 리스트로 인한 부가 비용은 줄어든다.
    // 이 때 각 중간 시퀀스는 람다를 필드에 저장하는 객체로 표현되며, 최종 연산은 중간 시퀀스에 있는 여러 람다를 연쇄 호출한다.
    // 따라서 시퀀스는 람다를 인라인하지 않는다.
    // 따라서 지연 계산을 통해 성능을 향상시키려는 이유로 모든 컬렉션 연산에 asSequence 를 붙여서는 안된다.
    // 시퀀스 연산에서는 람다가 인라이닝되지 않기 때문에 크기가 작은 컬렉션은 오히려 일반 컬렉션 연산이 더 성능이 나을 수도 있다.

    // 시퀀스를 통해 성능을 향상시킬 수 있는 경우는 컬렉션 크기가 큰 경우뿐이다.

}