package oop

/**
 * 취약한 기반 클래스 문제
 * 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면
 * 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로
 * 메소드를 오버라이드할 위험이 있다.
 *
 * [Effective Java](2008)에서는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라는 조언을 한다.
 * 이는 특별히 하위 클래스에서 오버라이드하게 의도된 클래스와 메소드가 아니라면 모두 final로 만들라는 뜻이다.
 * 코틀린도 마찬가지 철학을 따른다. 코틀린의 클래스와 메소드는 기본적으로 final이다.
 *
 * 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다.
 * 오버라이드를 허용하고 싶은 메소드나 프로퍼티도 마찬가지다.
 */

// 이 클래스는 열려 있다. 다른 클래스가 상속할 수 있다.
open class RichButton: Clickable {
    // 이 함수는 파이널이다. 하위 클래스가 오버라이드할 수 없다.
    fun disable() {}

    // 이 함수는 열려있다. 하위 클래스가 오버라이드해도 된다.
    open fun animate() {}

    // 이 함수는 열려있는 메소드를 오버라이드 한다. 오버라이드한 메소드는 기본적으로 열려있다.
    // 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final을 명시해야 한다.
    override fun click() {}
}

// 추상 클래스는 항상 열려있다.
abstract class Animated {
    // 추상 함수. 하위 클래스에서는 이 함수를 반드시 오버라이드해야 한다.
    abstract fun animate()

    // 추상 클래스에 속한 비추상 함수는 기본적으로 final.
    open fun stopAnimating() {}

    fun animateTwice() {}
}