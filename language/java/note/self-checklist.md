# 학습 내용 이해도 자가 진단표

## 프로그래밍 개론

#### 컴퓨터와 소프트웨어

- [o] 컴퓨터와 소프트웨어의 관계를 이해한다.
- [o] 시스템 소프트웨어와 응용 소프트웨어를 구분할 수 있다. `// 시스템 소프트웨어 : 하드웨어를 동작, 접근하는 소프트웨어, 응용소프트웨어에 플랫폼 제공`

#### 프로그램의 구동 원리

- [o] 컴퓨터에서 프로그램이 실행되는 원리를 이해한다.
- [o] CPU(ARM CPU 기준) 인스트럭션이 무엇인지 이해한다. `http://vision.gel.ulaval.ca/~jflalonde/cours/1001/h17/docs/arm-instructionset.pdf`
- [o] CPU 인스트럭션과 실행 파일, OS의 관계를 이해한다.
- [o] 같은 CPU에 맞춰 작성된 실행 파일이더라도 OS가 다르면 실행되지 않는 이유를 설명할 수 있다.

#### 중간 언어와 가상 머신

- [o] 중간 언어와 가상 머신이 등장한 이유와 이점을 설명할 수 있다. `// write once, run anywhere. 하드웨어나 운영체제에 맞춰 컴파일해야하는 불편함을 해결. 플랫폼에 독립적. 이식성을 높임.`
- [o] VM과 인터프리터, 런타임, 플레이어, 엔진의 역할을 이해한다.
- [o] JIT(Just-in-time)과 AOT(ahead-of-time)이 무엇이고 등장한 이유를 이해한다. //중간언어를 기계어로 바꿔 속도향상

#### 자바 바이트코드와 자바 가상 머신

`// 자바 컴파일러로 바이트코드 생성. 자바 가상 머신을 통해 바이트코드를 기계어로 바꿈.`

- [o] 자바 바이트코드 실행 환경을 준비할 수 있다. OpenJDK 설치, JAVA_HOME 과 PATH 환경 변수 설정, Sublime 편집기 설치.
- [o] 자바 바이트코드를 이해한다. `https://docs.oracle.com/javase/specs/jvms/se13/jvms13.pdf`
- [o] 바이트코드와 클래스 파일(.class)의 관계를 이해한다. `/HelloWorld.class`, `https://medium.com/@davethomas_9528/writing-hello-world-in-java-byte-code-34f75428e0ad`
- [o] 클래스 파일과 JVM의 관계를 이해한다. `$ javap HelloWorld.class`, `$ javap -verbose HelloWorld.class`
- [o] JVM을 이용하여 클래스 파일을 실행할 수 있다. \$ java HelloWorld

#### 프로그래밍 언어와 컴파일

- [o] 컴파일 방식 프로그래밍이 등장한 이유를 이해한다.
- [o] 프로그래밍 언어와 컴파일, CPU 인스트럭션의 관계를 이해한다.
- [o] 컴파일러를 이용하여 소스 코드(C 프로그래밍 언어 기준)를 목적 코드(CPU 인스트럭션)로 생성하는 과정을 이해한다. `/module.c`, `/main.c`, `$ gcc -c 소스파일`
- [o] 링커(C 프로그래밍 언어 기준)를 이용하여 목적 코드가 들어 있는 파일을 하나로 묶어 실행 파일을 만드는 과정을 이해한다. `$ ld -o 실행파일 목적파일 목적파일 … -lSystem -macosx_version_min 10.13`
- [o] C 프로그래밍 언어 기준, "소스 파일, 목적파일, 실행 파일"과 "컴파일러, 링커"의 관계를 이해한다.

#### 컴파일러와 인터프리터

- [o] 인터프리트 방식 프로그래밍과 실행 과정을 이해한다.
  `// 소스코드 -엔진(인터프리터)-> 기계어. 한줄씩 읽어서 문법 검사 후 실행`
- [o] Node.js 자바스크립트 인터프리터를 준비할 수 있다. `https://nodejs.org/en/`
- [o] 인터프리터(Node.js 기준)를 사용하여 소스 파일을 직접 실행하는 과정을 이해한다. `/hello.js`, `$ node hello.js`
- [o] 컴파일 방식과 인터프리트 방식의 구동 원리를 이해한다.
- [o] 컴파일 방식과 인터프리트 방식의 장단점을 비교할 수 있다.

#### 자바 프로그래밍 절차

- [o] 자바의 프로그래밍 방식과 실행 원리를 이해한다.
- [o] 자바 코드와 바이트코드, 소스 파일과 클래스 파일의 관계를 이해한다.
- [o] 자바 컴파일러와 JVM의 역할을 이해한다.
- [o] CLI 환경에서 컴파일을 수행할 수 있다. `/Hello.java`, `$ javac Hello.java`
- [o] CLI 환경에서 자바 클래스 파일을 실행할 수 있다. `/Hello.java`, `$ java Hello`

#### 소스 파일과 컴파일 결과 파일 분리

- [o] Maven 표준 디렉토리 구조를 만들 수 있다. Maven 표준 디렉토리 구조에 맞춰 폴더를 생성한다.
  `빌드 도구를 사용하면 표준 디렉토리 구조에 따라 폴더를 생성해줌`
  <pre>
  C:.
  ├─bin
  │  └─main
  │      └─com
  │          └─ohoracs
  │              ├─basic
  │              │  ├─ex01
  │              │  ├─ex02
  │              │  └─ex03
  │              └─ok
  └─src
      ├─main
      │  ├─java
      │  │  └─com
      │  │      └─ohoracs
      │  │          ├─basic
      │  │          │  ├─ex01
      │  │          │  ├─ex02
      │  │          │  └─ex03
      │  │          └─ok
      │  └─resources
      └─test
          ├─java
          └─resources
          </pre>
- [o] 각 디렉토리의 용도를 이해한다.
- [o] 프로젝트 디렉토리에서 소스 디렉토리에 있는 자바 소스 파일을 컴파일 할 수 있다. `src/main/java/Hello2.java`, `$ javac src/main/java/Hello2.java`
- [o] 컴파일 할 때 컴파일 결과로 생성된 클래스 파일을 별도 디렉토리에 분리할 수 있다. `src/main/java/Hello2.java`, `$ javac -d bin/main src/main/java/Hello2.java`
- [o] 다른 디렉토리에 있는 클래스 파일을 실행할 수 있다. `src/main/java/Hello2.java`, `$ java -classpath bin/main Hello2`

#### 패키지와 소스 파일

- [o] 패키지의 용도를 이해하고 패키지를 생성할 수 있다.
  `:원활한 class파일 관리와 유지 보수를 위해`
  `com.ohoracs.basic`, `src/main/java/com/ohoracs/basic 디렉토리 생성`
- [o] 소스 파일에 작성한 코드가 패키지에 소속되게 할 수 있다. `src/main/java/com/ohoracs/basic/Hello3.java`
- [o] 패키지에 소속된 소스 파일의 적절한 디렉토리 경로와 왜 그 위치에 놓아야 하는지 이해한다.
- [o] 컴파일 한 후 생성된 클래스 파일의 디렉토리 경로와 그 위치에 있어야 하는 이유를 안다.
  `// bin/main 밑에 src폴더처럼 java를 만들지 않는 이유 : java의 호환 언어 kotlin, groovy등은 컴파일 하면 똑같은 바이트코드 .class파일이 만들어지므로 구분이 무의미`
- [o] 패키지에 소속된 클래스 파일을 실행할 수 있다. `src/main/java/com/ohoracs/basic/Hello3.java`, `$ java -cp bin/main com.ohoracs.basic.Hello3`
- [o] 패키지를 적용하지 않은 채로 그 소스 파일을 그냥 패키지 폴더에 둔다면 컴파일 할 때 어떤 문제가 발생하는지 안다. `src/main/java/com/ohoracs/basic/Hello4.java`

#### Gradle 빌드 도구

- [o] Gradle 빌드 도구를 이용하여 작업 폴더를 자바 프로젝트 폴더로 구성할 수 있다. `/프로젝트폴더`, `$ gradle init`
- [o] Gradle로 생성된 src 디렉토리의 구조를 이해하고 설명할 수 있다. `/src`
- [o] src 디렉토리 외에 다른 디렉토리나 파일의 용도를 이해한다.

`$ gradle build` : 소스파일 컴파일과 배포파일 생성까지 한 번에 해결해줌

## 자바 기초 문법 - com.ohoracs.basic

#### 클래스 블록과 컴파일, 실행

- [o] 소스 파일(.java)과 클래스 블록(class 클래스명 {…}), 클래스 파일(.class) 관계를 이해한다. `ex01/Exam11.java`
- [o] 한 소스 파일에 여러 개의 클래스 블록이 있을 때 컴파일하면 어떻게 되는지 안다. `ex01/Exam12.java`
- [o] 클래스의 사용 범위(공개/비공개)에 따라 소스 파일과 클래스 블록의 이름이 어떤 관계가 있는지 안다. `ex01/Exam21.java, Exam22.java, Exam23.java`
  `공개 public인 경우 소스파일과 공개클래스의 이름을 일치시켜야 한다.(한 소스파일에 공개클래스는 하나)`
- [o] 컴파일 할 때 소스 파일의 인코딩을 지정할 수 있다. `ex01/Exam3.java`
  `$ javac -d 클래스파일을 저장할 경로 -encoding 인코딩규칙 소스파일위치/소스파일명.java`
- [o] JVM이 클래스를 실행하는 과정을 이해하고 설명할 수 있다.
  `$ java -cp 클래스파일위치 패키지명.클래스명`
- [o] main() 메서드의 용도를 알고 있으며 작성할 수 있다. `ex01/Exam4.java`
  `JVN이 class파일을 실행할 때 main() 메서드를 찾는다. 없으면 실핼 불가.`

#### 주석

- [o] 자바 소스 코드에 주석을 달 수 있다. `ex02/Exam1.java`
- [o] 주석(`//, /* … */`)의 종류와 작성법을 안다. `ex02/Exam1.java`
- [o] Javadoc 주석(`/** … */`)의 용도를 이해하고 이 주석을 이용하여 HTML 문서를 생성(`javadoc 사용`)할 수 있다. `ex02/Exam2.java`
- [o] 애노테이션(`@Override`)의 용도와 문법을 이해한다. `ex02/Exam3.java` <br>
  `VM과 컴파일러에게 지시할 때 사용하는 주석`

#### 데이터 종류에 따른 리터럴 표기법

- [o] `정수, 부동소수점, 논리, 문자, 문자열` 리터럴 문법의 용도를 이해한다. `ex03/Exam1.java`
- [o] 정수 리터럴을 10진수, 8진수, 2진수, 16진수로 표현할 수 있다. `ex03/Exam21.java`
- [o] 문자 '_' 를 사용하여 정수 리터럴의 자릿수를 표현할 수 있고, _ 문자의 적절한 위치를 안다. `ex03/Exam22.java`
- [o] 메모리에 값을 저장하기 위해 데이터를 2진수로 변환해야 하는 이유를 설명할 수 있다.
- [o] 메모리 크기에 따라 정수를 저장할 수 있는 범위가 다른 이유를 이해한다.
- [o] 메모리 크기에 따라 정수 리터럴을 4바이트와 8바이트로 구분하여 표현할 수 있다. `ex03/Exam23.java`
- [o] 정수 리터럴이 메모리 크기를 벗어날 때 어떤 문제가 발생하는지 안다. `ex03/Exam23.java`
- [o] 정수 리터럴이 메모리에 어떻게 저장되는지 이해한다. `ex03/Exam24.java`
- [o] 정수를 2진수로 표현하는 다양한 방법을 이해한다. (Sign-magnitude, 1의 보수, 2의 보수, Excess-K 방식)
- [o] 부동소수점 리터럴을 다양한 방식으로 표기할 수 있다. `ex03/Exam31.java`

        System.out.println(0.0314159e2); //0.0314159 * 10^2
        System.out.println(31.4159e-1);  //0.0314159 * 10^(-1)

- [o] 메모리 크기에 따라 부동소수점 리터럴을 4바이트와 8바이트로 구분하여 표현할 수 있다.`ex03/Exam32.java`
  `float, double`
- [o] 메모리 크기에 따라 부동소수점의 최소/최대 크기를 알아낼 수 있다. `ex03/Exam33.java`
  `유효자릿수> float : 7자리, double : 15자리까지 값이 정상적으로 들어가고, 자릿수가 커질수록 값이 달라질 위험성이 높아진다.'
- [o] 부동소수점이 메모리에 저장되는 원리를 이해한다. (IEEE 754 규칙에 따라 부동소수점이 2진수로 변환되는 것을 이해한다.) `ex03/Exam34.java`

        `부호비트 + 지수부 + 가수부`

* [o] 부동소수점이 때론 완전하게 2진수로 변환되지 못하는 이유를 안다.
* [o] 자바에서 부동소수점을 IEEE 754 규칙에 따라 2진수로 변환된 것을 확인해 볼 수 있다. `ex03/Exam35.java`
* [o] 문자 리터럴을 다양한 방식으로 표기할 수 있다. `ex03/Exam41.java`

        System.out.println((char)0x0041);   //A
        System.out.println((char)0x41);     //A
        System.out.println((char)0xac00);   //가

* [o] 문자 집합(character set), 유니코드, UCS, UTF, UTF-8, UTF-16의 의미를 이해한다. `ex03/Exam42.java`
* [o] ASCII, ISO-8859-1, EUC-KR, 조합형, MS949, Unicode의 의미를 이해한다.
* [o] UCS(ISO 10646)를 UTF-8로 바꾸는 규칙을 이해한다.

        - UCS의 UTF-8 변환 규칙
          000000 ~ 00007F: 0xxxxxxx
          000080 ~ 0007FF: 110yyyxx 10xxxxxx
          000800 ~ 00FFFF: 1110yyyy 10yyyyxx 10xxxxxx
          100000 ~ 10FFFF: 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
        - 대부분의 시스템에서 데이터 입출력 할 때 UTF-8을 사용한다.
        - 자바에서도 데이터 입출력할 때 주로 UTF-8을 사용하고 있다.
         한글은 3byte (유니코드에서는 2byte)

* [o] UCS 대신 UTF-8이 사용되는 이유를 안다.
  `기존처럼 영어를 1byte로 표현하고자 UTF-8 사용`
* [o] 문자를 다룰 때 작은 따옴표('')의 의미를 이해한다. `ex03/Exam43.java`
* [o] 논리 리터럴을 표현할 수 있다. `ex03/Exam5.java`
* [o] 문자열 리터럴을 표현할 수 있다. `ex03/Exam6.java`
* [o] 문자열과 다른 유형의 데이터를 결합할 때 어떤 결과가 발생하는지 안다. `ex03/Exam6.java`

        `문자열로 취급`

* [o] 이스케이스 문자의 역할과 사용법을 안다. `ex03/Exam7.java`

#### 변수

- [o] 변수를 선언할 수 있다. `ex04/Exam11.java`
- [o] 변수 선언의 의미를 설명할 수 있다. `ex04/Exam11.java`
- [o] 여러 개의 변수를 한 문장으로 선언할 수 있다. `ex04/Exam111.java`
- [o] 변수가 가리키는 메모리에 값을 저장할 수 있다. `ex04/Exam12.java`
- [o] 변수 선언할 때 값을 저장할 수 있다. `ex04/Exam121.java`
- [o] 한 문장으로 여러 개의 변수를 선언할 때에도 값을 저장할 수 있다. `ex04/Exam122.java`
- [o] 한 문장으로 여러 개의 변수를 선언할 때 일부 변수만 값을 저장할 수 있다. `ex04/Exam123.java`
- [o] 변수가 가리키는 메모리의 값을 변경할 수 있다. `ex04/Exam13.java`
- [o] 블록 안에서 변수를 선언할 수 있는 위치를 안다. `ex04/Exam14.java`
- [o] 변수를 먼저 사용하고 그 다음에 변수를 선언할 때 발생하는 문제를 안다. `ex04/Exam141.java`
- [o] 같은 이름의 변수를 중복해서 선언할 때 발생하는 문제를 안다. `ex04/Exam142.java`
- [o] 변수의 값을 출력할 수 있다. `ex04/Exam15.java`
- [o] 변수의 값을 다른 변수에 저장할 수 있다. `ex04/Exam151.java`
- [o] 변수를 초기화시키지 않은 후 사용하면 어떻게 되는지 안다. `ex04/Exam152.java,Exam153.java`
- [o] 값의 종류에 따라 변수를 선언할 수 있다. `ex04/Exam16.java`
- [o] primitive data type을 데이터 유형에 따라 크기에 따라 구분할 수 있다. `ex04/Exam16.java`
- [o] primitive data type 과 referece type을 구분할 수 있다. `ex04/Exam16.java`
- [o] 정수 데이터 타입(byte, short, int, long)의 각 변수의 메모리 크기와 이 메모리에 저장할 수 있는 최대, 최소 값을 안다. `ex04/Exam21.java`
  byte : -128 ~ 127
  short : -32768 ~ 32767
  int : 약 -21억 ~ 21억
  long : 약 -922경 ~ 922경
- [o] 4바이트와 8바이트 크기의 정수 리터럴을 각 타입의 변수에 저장할 때 규칙을 이해한다. `ex04/Exam22.java`

        자바의 정수 리터럴은 4바이트와 8바이트만 있다.
        그런데 4바이트 리터럴이라도 변수에 넣을 수 있다면 1바이트나 2바이트로 저장할 수 있다.
        8바이트 정수 리터럴은 불가능.


        byte b;
        b = 127;  // 127은 4바이트 정수 리터럴(int). 그러나 변수에 넣을 수 있기 때문에 1byte로 저장 가능.

        b = 128;  // 128도 4바이트 정수 리터럴(int)인데 byte타입 변수에 넣을 수 있는 수를 초과했기 때문에 때문에 저장 불가능.

        b = 10L;  // long 리터럴(8바이트)은 byte타입 변수에 저장할 수 있더라도 허락하지 않는다.

- [o] 작은 메모리에 큰 메모리의 값을 넣을 때 어떤 일이 일어나는지 안다. `ex04/Exam23.java`
- [o] 4바이트 부동소수점 변수에 넣을 수 있는 값의 최대, 최소 크기를 말할 수 있다. `ex04/Exam31.java`

        System.out.println(Float.MAX_VALUE);
        System.out.println(Float.MIN_VALUE);

- [o] 8바이트 부동소수점 변수에 넣을 수 있는 값의 최대, 최소 크기를 말할 수 있다. `ex04/Exam311.java`
- [o] 단정도, 배정도의 용어를 이해한다. `ex04/Exam311.java`
- [o] 부동소수점 리터럴의 크기에 따라 적절할 부동소수점 변수를 선언할 수 있다. `ex04/Exam32.java`
- [o] 잘못된 부동소수점 리터럴을 변수에 저장할 때 어떤 문제가 발생하는지 이해한다. `ex04/Exam321.java`
- [o] 부동소수점 변수끼리 연산할 때 결과가 부동소수점의 크기를 벗어날 경우 발생되는 문제를 안다. `ex04/Exam322.java`
- [o] 작은 부동소수점 메모리에 큰 부동소수점 메모리의 값을 넣을 때 발생되는 문제는 안다. `ex04/Exam33.java`
- [o] UCS-2에 정의된 문자 코드를 저장할 변수를 선언할 수 있다. `ex04/Exam41.java`

         char c1 = 65;             // A
        char c2 = 0x41;           // A
        char c3 = 0b0100_0001;    // A
        char c4 = 'A';            // A의 문자의 코드값이 변수 c4에 들어간다.(자바의 경우 유니코드 값; UCS-2 코드값)

- [o] char 변수에 저장할 수 있는 최대, 최소 값을 말 할 수 있다. `ex04/Exam41.java`

        c = 0;
        c = 65535;
        // c = -1;  컴파일 에러
        // c = 65536  컴파일 에러

- [o] char 변수에 문자의 UCS-2 코드 값을 저장하고 출력할 수 있다. `ex04/Exam42.java`
- [o] char 변수에 저장된 문자 코드를 화면에 출력할 때 문자로 표현하는 과정을 설명할 수 있다. `ex04/Exam42.java`

        `character set에서 문자 코드를 찾아 해당 이미지를 출력 : font`

- [o] 따옴표를 활용하여 문자의 UCS-2 코드 값을 알아낼 수 있다. `ex04/Exam43.java`

        int i2 = 'A';

- [o] 정수를 UCS-2 문자 코드로 인식하게 하여 문자를 출력할 수 있다. `ex04/Exam44.java`
