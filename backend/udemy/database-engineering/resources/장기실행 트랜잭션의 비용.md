장기 실행 트랜잭션의 비용
Postgress(혹은 다른 중요한 데이터베이스)에서 실패한 장기 실행 업데이트 트랜젝션 비용



Postgres에서 행을 변경하는 모든 DML 트랜잭션은 해당 행의 새 버전을 생성합니다. 행이 인덱스에서 참조되는 경우 해당 행도 새 튜플 ID로 업데이트해야 합니다. HOT(Hap Only Tuple - 힙 전용 튜플)과 같은 최적화에서는 인덱스를 업데이트를 해야 할 필요가 없지만 행이 있는 페이지에 충분한 공간 (fill factor < 100%)이 있을 때만 발생합니다.



수백만 개의 업데이트 된 행을 가진 긴 트랜잭션이 롤백되면, 이 트랜잭션이 생성한 새로운 행 버전(수백만 개인 경우)은 더 이상 유효하지 않으며 새로운 트랜잭션에서 읽어서는 안 됩니다. 이를 해결하기 위해 여러 가지 방법이 있습니다. 롤백시에 모든 불필요한 행을 즉시 정리하십니까? 아니면 후처리로 지연시점에서 처리하십니까? 아니면 테이블을 잠근 채로 데이터베이스가 완전히 재시작할 때까지 정리하십니까?



Postgres는 지연 방식을 채택하여 주기적으로 호출되는 vacuum이라는 명령을 사용합니다. Postgres는 불필요한 행을 제거하고 페이지의 공간을 확보하려고 합니다.



이러한 불필요한 행들을 그대로 두는 것에 어떤 문제가 있을까요? 실제로 올바르지 않은 문제들은 아니지만, 트랜잭션은 이러한 불필요한 행들을 생성한 트랜잭션의 상태를 확인하여 읽지 않아야 함을 알고 있습니다. 그러나 이는 생성한 트랜잭션이 커밋되거나 롤백되었는지 확인해야 하므로 비용이 많이 드는 작업입니다. 또한, 이러한 불필요한 행들이 다른 행들과 함께 디스크 페이지에 존재하게 되면, 데이터베이스는 불필요한 행들을 걸러내야 하므로 IO가 비효율적입니다. 예를 들어, 한 페이지에 1000개의 행이 있을 수 있지만, 오직 1개의 필요한 행과 999개의 불필요한 행들이 있는 경우, 데이터베이스는 해당 IO를 수행하지만 단 하나의 행만 얻게 됩니다. 이를 반복하면 더 많은 IO가 발생하게 됩니다. 더 많은 IO = 성능 저하.



다른 데이터베이스는 적극적인 방식을 사용하여 롤백이 성공적으로 완료될 때까지 데이터베이스를 시작할 수 없도록 undo 로그를 사용합니다. 어떤 것이 옳고 어떤 것이 틀린 걸까요? 여기가 바로 재미있어지는 부분이예요! 옳고 틀린 것은 없으며, 이 모두가 엔지니어가 내리는 결정입니다. 이 모든 것이 기본적인 것입니다. 이것을 이해하고 선택하는 것은 여러분에게 달려 있습니다. 어떤 방식이든 괜찮을 거예요. 무엇을 다루고 있는지 안다면 무엇이든지 다룰 수 있습니다.