# redux

### 액션
상태에 변화가 필요하면 액선 발생.
```
{
  type: 'TOGGLE_VALUE
}
```
액션은 반드시 type 필드를 가지고 있어야 한다.
```
{
  type: 'ADD_TODO',
  data: {
    id: 1,
    text: '리덕스 배우기'
  }
}
```

### 액션 생성 함수
액션 객체를 만들어 주는 함수
```
function addTodo(data) {
  return {
    type: 'ADD_TODO',
    data
  };
}
```

### 리듀서
변화를 일으키는 함수. 액션을 만들면 리듀서가 현재 상태와 액션 객체를 파라미터로 받아 새로운 상태를 만든다.
```
const initialState = {
  counter: 1
};
function reducer(state = initialState, action) {
  switch (action.type) {
    case INCREMENT:
      return {counter: state.counter + 1};
    default:
      return state;
  }
}
```

### 스토어
프로젝트에 리덕스를 적용하려면 스토어를 만들어야 한다.(프로젝트당 하나의 스토어) <br/>
스토어 안에는 현재 애플리케이션 상태와 리듀서, 내장 함수가 들어가 있다.

### 디스패치
스토어의 내장 함수 중 하나. 디스패치가 호출되면 스토어는 리듀서 함수를 실행시켜 새로운 상태를 만든다.

### 구독(subscribe)
subscribe도 스토어의 내장 함수 중 하나다. 함수 안에 리스너 함수를 파라미터로 넣어 호출한다. 상태가 업데이트 될 때마다 호출된다.

## 리액트 없이 쓰는 리덕스
리덕스는 다른 UI 라이브러리/프레임워크, 바닐라 자바스크립트와 함께 사용될 수도 있다.
### parcel로 프로젝트 만들기
```
$ yarn global add parcel-bundler
$ mkdir vanilla-redux
$ cd vanilla-redux
$ yarn init -y

$ parcel index.html
```

## 리덕스의 세 가지 규칙
1. 단일 스토어
1 애플리케이션 1 스토어
2. 읽기 전용 상태
리덕스 상태는 읽기 전용이다. 즉, 상태를 업데이트할 때 마다 불변성을 지켜 기존의 객체는 건드리지 않고 새로운 객체를 생성해 줘야 한다. -> 리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경되는 것을 감지하기 위해 얕은 비교 검사를 하기 때문이다.
3. 리듀서는 순수한 함수
변화를 일으키는 리듀서 함수는 순수한 함수여야 한다.
  - 이전 상태와 액션 객체를 파라미터로 받는다.
  - 파라미터 외의 값에는 의존하지 않는다.
  - 이전 상태는 절대로 건드리지 않고, 새로운 상태 객체를 만들어 반환한다.
  - 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과 값을 반환한다.
    => 리듀서 함수 내부에서 랜덤 값을 만들거나, 현재 시간을 가져오거나, 네트워크 요청 등의 행위는 하면 안된다. 이러한 작업은 리듀서 함수 바깥에서 처리할 것!
